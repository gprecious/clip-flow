import type { MediaFile, MediaFolder, TranscriptionSegment, TranscriptionMetadata, Summary, SummaryMetadata } from '@/context/MediaContext';
import type { DirectoryNode } from '@/lib/tauri';

/**
 * Mock transcription segments
 */
export const mockSegments: TranscriptionSegment[] = [
  { start: 0, end: 5.5, text: 'Hello world, this is a test.' },
  { start: 5.5, end: 10.2, text: 'This is the second segment.' },
  { start: 10.2, end: 15.0, text: 'And this is the final segment.' },
];

/**
 * Mock summary metadata (Ollama)
 */
export const mockSummaryMetadataOllama: SummaryMetadata = {
  provider: 'ollama',
  model: 'llama3.2',
  summarizedAt: Date.now(),
};

/**
 * Mock summary metadata (OpenAI)
 */
export const mockSummaryMetadataOpenAI: SummaryMetadata = {
  provider: 'openai',
  model: 'gpt-4o-mini',
  summarizedAt: Date.now(),
};

/**
 * Mock summary metadata (Claude)
 */
export const mockSummaryMetadataClaude: SummaryMetadata = {
  provider: 'claude',
  model: 'claude-3-haiku-20240307',
  summarizedAt: Date.now(),
};

/**
 * Mock summary with Ollama
 */
export const mockSummary: Summary = {
  text: 'This is a test summary of the transcription. The speaker discusses a test and mentions two additional segments.',
  language: 'English',
  metadata: mockSummaryMetadataOllama,
};

/**
 * Mock summary with OpenAI
 */
export const mockSummaryOpenAI: Summary = {
  text: 'This is a test summary generated by OpenAI. Key points include greetings and segment transitions.',
  language: 'English',
  metadata: mockSummaryMetadataOpenAI,
};

/**
 * Mock summary with Claude
 */
export const mockSummaryClaude: Summary = {
  text: 'Claude가 생성한 테스트 요약입니다. 주요 내용은 인사말과 세그먼트 전환입니다.',
  language: 'Korean',
  metadata: mockSummaryMetadataClaude,
};

/**
 * Mock media file in pending state
 */
export const mockPendingFile: MediaFile = {
  id: '/test/path/video.mp4',
  name: 'video.mp4',
  path: '/test/path/video.mp4',
  size: 1024 * 1024 * 100, // 100MB
  extension: 'mp4',
  modified: Date.now(),
  status: 'pending',
  progress: 0,
};

/**
 * Mock media file in extracting state
 */
export const mockExtractingFile: MediaFile = {
  ...mockPendingFile,
  id: '/test/path/extracting.mp4',
  name: 'extracting.mp4',
  path: '/test/path/extracting.mp4',
  status: 'extracting',
  progress: 30,
};

/**
 * Mock media file in transcribing state
 */
export const mockTranscribingFile: MediaFile = {
  ...mockPendingFile,
  id: '/test/path/transcribing.mp4',
  name: 'transcribing.mp4',
  path: '/test/path/transcribing.mp4',
  status: 'transcribing',
  progress: 60,
};

/**
 * Mock media file in completed state
 */
export const mockCompletedFile: MediaFile = {
  ...mockPendingFile,
  id: '/test/path/completed.mp4',
  name: 'completed.mp4',
  path: '/test/path/completed.mp4',
  status: 'completed',
  progress: 100,
  transcription: {
    segments: mockSegments,
    fullText: mockSegments.map((s) => s.text).join(' '),
    language: 'en',
    duration: 15,
  },
};

/**
 * Mock media file with local whisper metadata
 */
export const mockCompletedFileWithLocalMetadata: MediaFile = {
  ...mockCompletedFile,
  id: '/test/path/completed-local.mp4',
  name: 'completed-local.mp4',
  path: '/test/path/completed-local.mp4',
  transcription: {
    ...mockCompletedFile.transcription!,
    metadata: {
      provider: 'local',
      model: 'base',
      transcribedAt: Date.now(),
    },
  },
};

/**
 * Mock media file with OpenAI metadata
 */
export const mockCompletedFileWithOpenAIMetadata: MediaFile = {
  ...mockCompletedFile,
  id: '/test/path/completed-openai.mp4',
  name: 'completed-openai.mp4',
  path: '/test/path/completed-openai.mp4',
  transcription: {
    ...mockCompletedFile.transcription!,
    metadata: {
      provider: 'openai',
      model: 'whisper-1',
      transcribedAt: Date.now(),
    },
  },
};

/**
 * Mock media file in error state
 */
export const mockErrorFile: MediaFile = {
  ...mockPendingFile,
  id: '/test/path/error.mp4',
  name: 'error.mp4',
  path: '/test/path/error.mp4',
  status: 'error',
  progress: 0,
  error: 'Transcription failed: Model not found',
};

/**
 * Mock audio file
 */
export const mockAudioFile: MediaFile = {
  id: '/test/path/audio.mp3',
  name: 'audio.mp3',
  path: '/test/path/audio.mp3',
  size: 1024 * 1024 * 10, // 10MB
  extension: 'mp3',
  modified: Date.now(),
  status: 'pending',
  progress: 0,
};

/**
 * Mock empty folder
 */
export const mockEmptyFolder: MediaFolder = {
  id: '/test/empty',
  name: 'empty',
  path: '/test/empty',
  files: [],
  subfolders: [],
  isExpanded: true,
};

/**
 * Mock folder with files
 */
export const mockFolderWithFiles: MediaFolder = {
  id: '/test/path',
  name: 'path',
  path: '/test/path',
  files: [mockPendingFile, mockCompletedFile],
  subfolders: [],
  isExpanded: true,
};

/**
 * Mock nested folder structure
 */
export const mockNestedFolder: MediaFolder = {
  id: '/test/root',
  name: 'root',
  path: '/test/root',
  files: [mockPendingFile],
  subfolders: [
    {
      id: '/test/root/subfolder1',
      name: 'subfolder1',
      path: '/test/root/subfolder1',
      files: [mockCompletedFile],
      subfolders: [],
      isExpanded: false,
    },
    {
      id: '/test/root/subfolder2',
      name: 'subfolder2',
      path: '/test/root/subfolder2',
      files: [mockAudioFile],
      subfolders: [],
      isExpanded: true,
    },
  ],
  isExpanded: true,
};

/**
 * Mock DirectoryNode from Tauri (raw scan result)
 */
export const mockDirectoryNode: DirectoryNode = {
  path: '/test/path',
  name: 'path',
  is_dir: true,
  size: 0,
  modified: Date.now(),
  extension: null,
  children: [
    {
      path: '/test/path/video.mp4',
      name: 'video.mp4',
      is_dir: false,
      size: 1024 * 1024 * 100,
      modified: Date.now(),
      extension: 'mp4',
      children: [],
    },
    {
      path: '/test/path/audio.mp3',
      name: 'audio.mp3',
      is_dir: false,
      size: 1024 * 1024 * 10,
      modified: Date.now(),
      extension: 'mp3',
      children: [],
    },
  ],
};

/**
 * Mock nested DirectoryNode
 */
export const mockNestedDirectoryNode: DirectoryNode = {
  path: '/test/root',
  name: 'root',
  is_dir: true,
  size: 0,
  modified: Date.now(),
  extension: null,
  children: [
    {
      path: '/test/root/video.mp4',
      name: 'video.mp4',
      is_dir: false,
      size: 1024 * 1024 * 100,
      modified: Date.now(),
      extension: 'mp4',
      children: [],
    },
    {
      path: '/test/root/subfolder',
      name: 'subfolder',
      is_dir: true,
      size: 0,
      modified: Date.now(),
      extension: null,
      children: [
        {
          path: '/test/root/subfolder/audio.mp3',
          name: 'audio.mp3',
          is_dir: false,
          size: 1024 * 1024 * 10,
          modified: Date.now(),
          extension: 'mp3',
          children: [],
        },
      ],
    },
  ],
};

/**
 * Create a mock media file with custom properties
 */
export function createMockMediaFile(overrides: Partial<MediaFile> = {}): MediaFile {
  return {
    ...mockPendingFile,
    id: `/test/path/${overrides.name ?? 'file.mp4'}`,
    path: `/test/path/${overrides.name ?? 'file.mp4'}`,
    ...overrides,
  };
}

/**
 * Create a mock folder with custom files
 */
export function createMockFolder(
  name: string,
  files: MediaFile[] = [],
  subfolders: MediaFolder[] = []
): MediaFolder {
  return {
    id: `/test/${name}`,
    name,
    path: `/test/${name}`,
    files,
    subfolders,
    isExpanded: true,
  };
}

/**
 * Options for creating nested directory structures
 */
interface CreateNestedOptions {
  basePath?: string;
  includeFileAtEachLevel?: boolean;
}

/**
 * Create a deeply nested DirectoryNode structure
 * @param depth - Number of nested levels (0 = root only, 5 = root + 5 nested levels)
 * @param options - Configuration options
 */
export function createNestedDirectoryNode(
  depth: number,
  options: CreateNestedOptions = {}
): DirectoryNode {
  const { basePath = '/test/root', includeFileAtEachLevel = true } = options;

  const extensions = ['mp4', 'mp3', 'mkv', 'wav', 'mov', 'flac'];

  function buildLevel(currentDepth: number, parentPath: string): DirectoryNode {
    const levelName = currentDepth === 0 ? 'root' : `level${currentDepth}`;
    const path = currentDepth === 0 ? basePath : `${parentPath}/${levelName}`;
    const ext = extensions[currentDepth % extensions.length];

    const children: DirectoryNode[] = [];

    // Add file at this level if requested
    if (includeFileAtEachLevel) {
      children.push({
        path: `${path}/file-${levelName}.${ext}`,
        name: `file-${levelName}.${ext}`,
        is_dir: false,
        size: 1024 * 1024 * (currentDepth + 1),
        modified: Date.now(),
        extension: ext,
        children: [],
      });
    }

    // Add nested folder if not at max depth
    if (currentDepth < depth) {
      children.push(buildLevel(currentDepth + 1, path));
    }

    return {
      path,
      name: levelName,
      is_dir: true,
      size: 0,
      modified: Date.now(),
      extension: null,
      children,
    };
  }

  return buildLevel(0, '');
}

/**
 * Create a deeply nested MediaFolder structure
 * @param depth - Number of nested levels (0 = root only, 5 = root + 5 nested levels)
 * @param options - Configuration options
 */
export function createNestedFolder(
  depth: number,
  options: CreateNestedOptions = {}
): MediaFolder {
  const { basePath = '/test/root', includeFileAtEachLevel = true } = options;

  const extensions = ['mp4', 'mp3', 'mkv', 'wav', 'mov', 'flac'];

  function buildLevel(currentDepth: number, parentPath: string): MediaFolder {
    const levelName = currentDepth === 0 ? 'root' : `level${currentDepth}`;
    const path = currentDepth === 0 ? basePath : `${parentPath}/${levelName}`;
    const ext = extensions[currentDepth % extensions.length];

    const files: MediaFile[] = [];
    const subfolders: MediaFolder[] = [];

    // Add file at this level if requested
    if (includeFileAtEachLevel) {
      const filePath = `${path}/file-${levelName}.${ext}`;
      files.push({
        id: filePath,
        name: `file-${levelName}.${ext}`,
        path: filePath,
        size: 1024 * 1024 * (currentDepth + 1),
        extension: ext,
        modified: Date.now(),
        status: 'pending',
        progress: 0,
      });
    }

    // Add nested folder if not at max depth
    if (currentDepth < depth) {
      subfolders.push(buildLevel(currentDepth + 1, path));
    }

    return {
      id: path,
      name: levelName,
      path,
      files,
      subfolders,
      isExpanded: true,
    };
  }

  return buildLevel(0, '');
}

/**
 * Mock deeply nested DirectoryNode (6 levels: depth 0-5)
 * Structure:
 * /test/root/
 *   ├── file-root.mp4
 *   └── level1/
 *       ├── file-level1.mp3
 *       └── level2/
 *           ├── file-level2.mkv
 *           └── level3/
 *               ├── file-level3.wav
 *               └── level4/
 *                   ├── file-level4.mov
 *                   └── level5/
 *                       └── file-level5.flac
 */
export const mockDeeplyNestedDirectoryNode: DirectoryNode = createNestedDirectoryNode(5);

/**
 * Mock deeply nested MediaFolder (6 levels: depth 0-5)
 */
export const mockDeeplyNestedFolder: MediaFolder = createNestedFolder(5);
